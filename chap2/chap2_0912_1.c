// 실습 : 2-4.cpp

/*
    int, long : 4바이트 : 32비트
    short : 2바이트 : 16비트 

    char : 1바이트 : 8비트

    float : 4바이트 : 32비트
    double : 8바이트 : 64비트

    unsigned : 부호 없이 출력 (음수 X)
*/

#include <stdio.h>

int main() 
{
    int i = 31; 
    long j = 2147483647;
    double x = 131.274;

    printf ("%14d\n", i); // 14칸 띄워서 오른쪽정렬 출력
    printf ("%-14d\n", i); // 왼쪽으로 바싹 붙여서 출력 

    printf ("%ld\n", j); // long형 정수 출력 (long으로 선언하였으면 %ld 사용하기)

    printf ("%14.1f\n", x); // 14칸 띄워서 소수점 1자리까지 오른쪽정렬 출력 (반올림함)
    printf ("%14.3f\n", x); // 위와 같은데 얘는 소수점 3자리까지 (반올림)
    printf ("%14.3e\n", x); 

    printf ("%f\n", x); // 소수점에 대한 서식지정 없으면 6자리까지 출력
    printf ("%e\n", x);

    return 0;
}

/* 복습
(자료형 : 바이트 수 : 비트 수 : 범위 : unsigned 범위)
int, long : 4바이트 : 32비트 : -2^31 ~ 2^31-1 : 0 ~ 2^32-1 (long은 ld)
short : 2바이트 : 16비트 : -2^15 ~ 2^15-1: 0 ~ 2^16-1
char : 1바이트 : 8비트 : -2^7 ~ 2^7-1 : 0 ~ 2^8-1
float : 4바이트 : 32비트 : -2^31 ~ 2^31-1 : 0 ~ 2^32-1 (float는 연산 시엔 절대로 사용하지 말 것 : 부동 소수점의 잘림 현상 때문)
double : 8바이트 : 64비트 : -2^63 ~ 2^63-1 : 0 ~ 2^64-1 

printf나 scanf_s는 기본적으로 제어 문자열과 인수로 구성되어 있으며,
제어 문자열은 다시 escape character와 변환 지시자로 나뉜다. 
또한, 변환 지시자의 커스터마이징이 가능하다. (서식 지정을 통해)
scanf_s에 인수를 작성할 때엔, 문자열이 아니면 반드시 &(주소)를 앞에 붙인다.
*/
